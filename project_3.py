# -*- coding: utf-8 -*-
"""Project-3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MPYkLN3iQr-oqN1N6652dQ4wWrTCK3jV
"""

# Install libraries
!pip install transformers datasets accelerate

# Verify GPU
import torch
print("GPU Available:", torch.cuda.is_available())

# Load dataset
from datasets import load_dataset
dataset = load_dataset("imdb")

# Preprocess
def preprocess_function(examples):
    return {"text": examples["text"].lower()}
dataset = dataset.map(preprocess_function, batched=True)

# Load model and tokenizer
from transformers import AutoModelForSequenceClassification, AutoTokenizer
model_name = "distilbert-base-uncased"
model = AutoModelForSequenceClassification.from_pretrained(model_name, num_labels=2)
tokenizer = AutoTokenizer.from_pretrained(model_name)

# Tokenize
def tokenize_function(examples):
    return tokenizer(examples["text"], truncation=True, padding="max_length", max_length=512)
tokenized_dataset = dataset.map(tokenize_function, batched=True)

# Training arguments
from transformers import TrainingArguments
training_args = TrainingArguments(
    output_dir="./results",
    evaluation_strategy="epoch",
    learning_rate=2e-5,
    per_device_train_batch_size=16,
    per_device_eval_batch_size=16,
    num_train_epochs=3,
    weight_decay=0.01,
    save_strategy="epoch",
    logging_dir="./logs",
)

# Trainer
from transformers import Trainer
trainer = Trainer(
    model=model,
    args=training_args,
    train_dataset=tokenized_dataset["train"],
    eval_dataset=tokenized_dataset["test"],
)

# Train
trainer.train()

# Save model
model.save_pretrained("./fine_tuned_model")
tokenizer.save_pretrained("./fine_tuned_model")

# Evaluate
eval_results = trainer.evaluate()
print("Evaluation Results:", eval_results)

# Classification report
from sklearn.metrics import classification_report
predictions = trainer.predict(tokenized_dataset["test"])
y_pred = predictions.predictions.argmax(axis=1)
y_true = tokenized_dataset["test"]["label"]
print(classification_report(y_true, y_pred, target_names=["negative", "positive"]))